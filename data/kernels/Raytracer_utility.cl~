#define STACK_DEPTH 20
#define TRACE_DEPTH 10
#define EPSILON 0.001f







//---------------------------------------Data structures------------------------------//



struct Ray
{
	float4 origin;
	float4 dir;
};



//--------------------------------------------------------//



struct RayStack
{
	struct Ray r[STACK_DEPTH];
	int depth[STACK_DEPTH];
	float refr[STACK_DEPTH];
	int top;
};



//--------------------------------------------------------//




struct Material
{
	float refl;
	float refr;
	float diff;
	float spec;
	float4 amb;
};



//--------------------------------------------//




struct Material *GetMaterialFromIndex(__global float * data, int material_index)
{


	struct Material material;
	material.refl = data[material_index];
	material.refr = data[material_index + 1];
	material.spec = data[material_index + 2];
	material.diff = data[material_index + 7];
	material.amb = (float4)(data[material_index + 3], data[material_index + 4], data[material_index + 5], data[material_index + 6]);



    return *material;

}




//--------------------------------------------------------//


struct IntersectionResult
{
	int result;
	float4 normal;
	float4 position;
	float distance;
	struct Material *material;
};






//------------------------------------------Ray tracing functions------------------------------------------//





float4 planenormal(float4 plane_normal)
{
	return plane_normal;
}




//-----------------------------------------------------------------------//






int planeintersect(float4 plane_normal, float plane_distance, struct Ray *r, float *dist)
{
	float d = (-dot(plane_normal, r->origin) + plane_distance) / dot(plane_normal, r->dir);

	if(d > 0 && d < *dist)
	{
		*dist = d; 
		return 1;
	}

	return 0;
}




//-------------------------------------------------------------------------//




float4 spherenormal(float4 sphere_center, float4 poi)
{
	return normalize(poi - sphere_center);
}




//-------------------------------------------------------------------------//




int sphereintersect(float4 sphere_center, float sphere_radius, struct Ray *r, float *dist)
{


	float4 v = r->origin - sphere_center;
	float b = -dot(v, r->dir);
	float det = (b * b) - dot(v, v) + sphere_radius;



	if(det > 0)
	{
		det = sqrt(det);
		float i1 = b - det;
		float i2 = b + det;

		if(i2 > 0)
		{
			if(i1 < 0)
			{
				if(i2 < *dist) { *dist = i2; return -1; }
			}
			else
			{
				if(i1 < *dist) { *dist = i1; return 1; }
			}
		}
	}

	return 0;
}





//-----------------------------------------------------------------//







void push(struct RayStack *s, struct Ray *r, float refr, int depth)
{
	if(s->top < STACK_DEPTH)
	{
		s->r[s->top].dir = r->dir;
		s->r[s->top].origin = r->origin;
		s->refr[s->top] = refr;
		s->depth[s->top] = depth;
		s->top++;
	}
}







//----------------------------------------------------------------//





int findintersection(__global float* data, struct Ray *r, struct IntersectionResult *intersection)
{



	int result = 0;
	float dist = MAXFLOAT;
	int sphere = -1;
	int plane  = -1;





//Check for sphere intersection
	for(int i = data[0]; i < data[1]; i += 6)
	{
		int res = sphereintersect((float4)(data[i], data[i + 1], data[i + 2], data[i + 3]), data[i + 4], r, &dist);
		if(res) result = res, sphere = i;
		if(res && !intersection) return res;
	}




//Check for plane intersection
	for(int i = data[1]; i < data[2]; i += 6)
	{
		int res = planeintersect((float4)(data[i], data[i + 1], data[i + 2], data[i + 3]), data[i + 4], r, &dist);
		if(res) result = res, plane = i;
		if(res && !intersection) return res;
	}








//Handle intersection result
	if(intersection)
	{


		intersection->result = result;
		intersection->distance = dist;
		intersection->position = r->origin + r->dir * dist;


		if(plane != -1)
		{
			intersection->normal = planenormal((float4)(data[plane], data[plane + 1], data[plane + 2], data[plane + 3]));
			int material_index = data[plane + 5] * 8 + data[2];
			intersection->material = GetMaterialFromIndex(data, material_index);

		}
		else if(sphere != -1)
		{
			intersection->normal = spherenormal((float4)(data[plane], data[plane + 1], data[plane + 2], data[plane + 3]), intersection->position);
			int material_index = data[sphere + 5] * 8 + data[2];
			intersection->material = GetMaterialFromIndex(data, material_index);
		}



	}




	return result;
}



//-----------------------------------------------------------------------//




float shadowray(__global float* data, float4 L, float4 P)
{


	float t = length(L);
	L *= 1.f / t;


	struct Ray light;
	light.origin = P + L * EPSILON;
	light.dir = L;


	return findintersection(data, &light, 0) ? 0.0f : 1.0f;
}



//----------------------------------------------------------------------//




float4 raytrace(__global float* data, struct RayStack *stack, struct Ray *r, float refr, int depth)
{




	float4 color = (float4)(0, 0, 0, 0);
	if(depth > TRACE_DEPTH) return color;




	struct IntersectionResult intersection;
	int result = findintersection(data, r, &intersection);
	if(result == 0) return color;




	struct Material *m  = intersection.material;
	float4 P = intersection.position;
	float4 N = intersection.normal;




	//Handle scene lights
	for(int i = data[3]; i < data[4]; i += 5)
	{

		int material_index = data[i + 4] * 8 + data[2];
		struct Material *lm = GetMaterialFromIndex(data, material_index);
		float4 L = (float4)(data[i], data[i + 1], data[i + 2], data[i + 3]) - P;




		float shade = shadowray(data, L, P);
		L = normalize(L);
		float angle = fmax(0.f, dot(N, L)) * shade;
		float s = dot(r->dir, reflect(N, L)) * shade;




		color += angle * m->diff * m->amb * lm->amb 
		+ powr(fmax(0.f, s), m->spec) * lm->amb;


	}




	//Handle reflection
	if(m->refl > 0)
	{
		float4 refl = reflect(N, r->dir);

		struct Ray R;
		R.origin = P + refl * EPSILON;
		R.dir = refl;

		push(stack, &R, refr, depth + 1);
	}



	//Handle refraction
	if(m->refr > 0)
	{
		float4 refrN = N * (float)result;
		float n = refr / m->refr;
		float cos_i = -dot(refrN, r->dir);
		float cos_t2 = 1.f - n * n * (1 - cos_i * cos_i);

		if(cos_t2 > 0)
		{
			float4 T = n * r->dir + (n * cos_i - sqrt(cos_t2)) * refrN;

			struct Ray R;
			R.origin = P + T * EPSILON;
			R.dir = T;

			push(stack, &R, m->refr, depth + 1);
		}
	}


	return color;




}






float4 recursivetrace(__global float* data, struct Ray *r)
{


	struct RayStack stack;
	stack.top = 0;
	push(&stack, r, 1.f, 0);

	float4 c = (float4)(0, 0, 0, 0);

	while(stack.top > 0)
	{
		stack.top--;
		c += raytrace(data, &stack, &stack.r[stack.top], stack.refr[stack.top], stack.depth[stack.top]);
	}

	return c;



}
